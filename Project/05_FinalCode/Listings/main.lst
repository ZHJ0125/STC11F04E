C51 COMPILER V9.57.0.0   MAIN                                                              12/04/2019 10:54:19 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\MDK\install\Core\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg51.h>
   2          #include <intrins.h>
   3          #define uchar unsigned char
   4          #define uint unsigned int
   5          #define dec(dat) ((dat>>4)*10+(dat&0x0f))               // BCD码转十进制
   6          
   7          sbit IO = P1^4;                                 // DS1302 数据输入输出线
   8          sbit RST = P1^6;                                // DS1302 复位信号线
   9          sbit SCLK = P1^5;                               // DS1302 时钟信号线
  10          sbit DS = P1^7;                                 // DS18B20 数据端口
  11          sbit DAT = P3^0;                                // 74HC164 数据输入端口
  12          sbit CLK = P3^1;                                // 74HC164 时钟输入端口
  13          sbit DP = P3^7;                                 // 时间分割点
  14          sbit DP1 = P3^5;                                // 温度小数点
  15          sbit KEY = P3^2;                                // 按键INT0
  16          uint flag = 0;                                  // 时间小数点闪烁计数
  17          uint temp;                                              // 温度变量
  18          uint DISP_FLAG = 1;                             // 功能显示标志位
  19          
  20          uchar code write_addr[]={0x80,0x82,0x84,0x86,0x88,0x8a,0x8c};           // DS1302写地址
  21          uchar code read_addr[]={0x81,0x83,0x85,0x87,0x89,0x8b,0x8d};            // DS1302读地址
  22          
  23          // 定义数码管段选(不加小数点0~9、℃)
  24          uchar code table1[]={0x81,0xD7,0xC8,0xC2,0x96,0xA2,0xA0,0xC7,0x80,0x82,0xA9};
  25          
  26          // 存储顺序是秒分时日月周年,存储格式是用BCD码
  27          uchar time[7]={0,0x55,0x18,0x04,0x10,0x05,0x19};  //初始化的时间为2019年10月4日18:55:00
  28          
  29          
  30          
  31          /**********************************************************
  32          *  函数名称：低精度延时函数
  33          *  日期：2019-9-7
  34          *  姓名：ZhangHJ
  35          *  说明：嵌套循环延时
  36          ***********************************************************/
  37          void delay(unsigned int mstime)
  38          {
  39   1              int i,j;
  40   1              for(i=mstime; i>=0; i--)
  41   1                      for(j=114; j>=0; j--);
  42   1      }
  43          
  44          
  45          
  46          /**********************************************************
  47          *  函数名称：精确延时50ms函数
  48          *  日期：2019-10-25
  49          *  姓名：ZhangHJ
  50          *  说明：由STC-ISP自动生成
  51          ***********************************************************/
  52          void Delay50ms()                //@11.0592MHz
  53          {
  54   1              unsigned char i, j, k;
C51 COMPILER V9.57.0.0   MAIN                                                              12/04/2019 10:54:19 PAGE 2   

  55   1              _nop_();
  56   1              _nop_();
  57   1              i = 3;
  58   1              j = 26;
  59   1              k = 223;
  60   1              do
  61   1              {
  62   2                      do
  63   2                      {
  64   3                              while (--k);
  65   3                      } while (--j);
  66   2              } while (--i);
  67   1      }
  68          
  69          
  70          
  71          /**********************************************************
  72          *  函数名称：74HC164发送Byte数据函数
  73          *  日期：2019-9-29
  74          *  姓名：ZhangHJ
  75          *  说明：74HC164移位寄存器输入一字节数据发给寄存器
  76          ***********************************************************/
  77          void SendByte_74HC164(uchar byte)
  78          {
  79   1              uchar num,c;
  80   1              num=table1[byte];
  81   1              for(c=0; c<8; c++)
  82   1              {
  83   2                      DAT=num&0x01;                   // P3^0 --> 0000 000x
  84   2                      CLK=0;                                  // 制造一个上升沿
  85   2                      CLK=1;
  86   2                      num>>=1;                                // 将数据发送到寄存器
  87   2              }
  88   1      }
  89          
  90          
  91          
  92          /**********************************************************
  93          *  函数名称：DS18B20发送复位和初始化命令函数
  94          *  修改日期：2019-9-9
  95          *  修改人：ZhangHJ
  96          *  说明：1. 对于单片机: 单片机首先发出480-960us的低电平脉冲,
  97          *                                               释放总线为高电平(上拉电阻拉高),在随后的480us进行检测,
  98          *                                               如果出现低电平，说明器件应答正常.B
  99          *               2. 对于DS18B20: 上电后就检测是否有480/960us的低电平脉冲,
 100          *                                               s如果有低电平,在总线释放之后，等待15-60us,
 101          *                                               将电平拉低60-240us,告诉主机已经准备好.
 102          ***********************************************************/
 103          uchar dsreset(void)                                                     // send reset and initialization command
 104          {
 105   1        uint i;
 106   1        DS = 0;                                                                       // 先将端口拉低
 107   1        i=120;                                                                        // 维持低电平状态480us~960us
 108   1        while(i>0)i--;
 109   1        DS = 1;                                                                       // 然后释放总线(将总线拉高),若DS18B20做出反应,将会将在15us~60us后将总线拉低
 110   1              // 等待DS18B20响应
 111   1              i = 0;
 112   1              while(DS)                                                               // 在DS高电平时等待
 113   1              {
 114   2                      i++;
 115   2                      if(i > 50000)                                           // 等待时间大于60us,说明响应失败
 116   2                      {
C51 COMPILER V9.57.0.0   MAIN                                                              12/04/2019 10:54:19 PAGE 3   

 117   3                              return 0;
 118   3                      }
 119   2              }
 120   1              return 1;
 121   1      }
 122          
 123          
 124          
 125          /**********************************************************
 126          *  函数名称：DS18B20读1bit数据函数
 127          *  修改日期：2019-9-9
 128          *  修改人：ZhangHJ
 129          *  说明：1.首先单片机端口拉低 1 us (i++),
 130          *                                2.然后释放总线,拉高总线,
 131          *                                3.等待几位秒，是为了让 DS18B20 数据稳定,
 132          *                                4.在15 us 内读取DS数据,
 133          *                                5.接下来进行延时等待采样周期完成。
 134          *                                详见DS18B20资料2.8.3.1读/写时间片
 135          ***********************************************************/
 136          bit tmpreadbit(void)                                    // read a bit data
 137          {
 138   1              uint i;
 139   1              bit dat;                                                        // 定义位数据 (dat = 0 or 1)
 140   1              DS = 0;                                                         // 先将端口拉低
 141   1              _nop_();                                                        // 延时 2us ,要求至少保持1us
 142   1              DS = 1;                                                         // 再将端口拉高
 143   1              i=8;while(i>0)i--;                                      // 等待DS数据稳定,要求的至少延时15us以上
 144   1              dat = DS;                                                       // 数据传输
 145   1              i=15;while(i>0)i--;                                     // 等待数据采样周期完成,要求不低于60us
 146   1              return (dat);
 147   1      }
 148          
 149          
 150          
 151          /**********************************************************
 152          *  函数名称：DS18B20读1Byte数据函数
 153          *  修改日期：2019-9-9
 154          *  修改人：ZhangHJ
 155          *  说明：1.首先初始化字节数据变量dat为 0
 156          *                                2.循环 8 次,调用tmpreadbit函数,读 8bit 数据
 157          *                                3.读出的数据暂存到 j ,之后进行移位和按位或操作
 158          *                                4.效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
 159          *                                5.最后返回读到的字节数据
 160          ***********************************************************/
 161          uchar tmpread(void)                                             // read a byte date
 162          {
 163   1              uchar i,j,dat;
 164   1        dat = 0;                                                              // 初始化数据变量为 0
 165   1        for(i=1;i<=8;i++)                                             // 循环 8 次,调用tmpreadbit函数,读 8bit 数据
 166   1        {
 167   2          j = tmpreadbit();                                   // 读出的数据暂存到 j
 168   2          dat = (j<<7)|(dat>>1);                              // 效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
 169   2        }
 170   1        return(dat);                                                  // 返回读到的字节
 171   1      }
 172          
 173          
 174          
 175          /**********************************************************
 176          *  函数名称：DS18B20写入1Byte数据函数
 177          *  修改日期：2019-9-11
 178          *  修改人：ZhangHJ
C51 COMPILER V9.57.0.0   MAIN                                                              12/04/2019 10:54:19 PAGE 4   

 179          *  说明：1.将对待写入数据dat进行位操作,将dat末位数值赋值给位数据testb
 180          *                                2.通过判断testb得到写 0 还是写 1
 181          *                                3.若是写 0 操作,将 DS 拉低,进行<60us的延时,再将DS拉高,进行>1us的延时
 182          *                                4.若是写 1 操作,将 DS 拉低,进行>1us的延时,再将DS拉高,进行<60us的延时
 183          *                                5.循环执行2、3、4操作8次,写入1字节数据
 184          *                                详见18B20资料“2.8.3.1读/写时间片”章节
 185          ***********************************************************/
 186          void tmpwritebyte(uchar dat)                    //write a byte to ds18b20
 187          {
 188   1        uint i;
 189   1        uchar j;
 190   1        bit testb;
 191   1        for(j=1;j<=8;j++)
 192   1        {
 193   2          testb = dat&0x01;
 194   2          dat = dat>>1;
 195   2          if(testb)                                                   // write 1
 196   2          {
 197   3            DS=0;
 198   3            i=8;while(i>0)i--;;                               // 延时要求15~60us内
 199   3            DS=1;
 200   3            i=15;while(i>0)i--;                               // 要求不低于60us
 201   3          }
 202   2          else
 203   2          {
 204   3            DS = 0;                                           // write 0
 205   3            i=15;while(i>0)i--;
 206   3            DS = 1;
 207   3            i++;i++;
 208   3          }
 209   2        }
 210   1      }
 211          
 212          
 213          
 214          /**********************************************************
 215          *  函数名称：DS18B20温度转换函数
 216          *  修改日期：2019-9-11
 217          *  修改人：ZhangHJ
 218          *  说明：1.首先进行18B20初始化
 219          *                                2.进行适当延时
 220          *                                3.发送跳过光刻ROM指令
 221          *                                4.发送RAM指令,进行温度转换
 222          *                                详见18B20资料“2.8.3.1存储器操作命令”章节
 223          ***********************************************************/
 224          void tmpchange(void)                                    // DS18B20 begin change
 225          {
 226   1        while(dsreset() == 0)
 227   1              {
 228   2                      SendByte_74HC164(0);
 229   2                      P1 &= 0xfB;
 230   2              }
 231   1        delay(1);
 232   1        tmpwritebyte(0xCC);                                   // 跳过 ROM 操作
 233   1        tmpwritebyte(0x44);                                   // 启动一次温度转换
 234   1      }
 235          
 236          
 237          
 238          /**********************************************************
 239          *  函数名称：DS18B20温度转换完整过程函数
 240          *  修改日期：2019-9-11
C51 COMPILER V9.57.0.0   MAIN                                                              12/04/2019 10:54:19 PAGE 5   

 241          *  修改人：ZhangHJ
 242          *  说明：1.首先进行18B20初始化
 243          *                                2.进行适当延时
 244          *                                3.发送跳过光刻ROM指令
 245          *                                4.发送RAM指令,进行温度转换
 246          *                                5.读取两个8位数据,放到16位寄存器 temp 中
 247          *                                6.将读取到的二进制数据(默认为正数),转换为十进制数据
 248          *                                7.返回温度数据
 249          *                                详见18B20资料“2.8.3.1存储器操作命令”章节
 250          ***********************************************************/
 251          uint tmp()                                                              // get the temperature
 252          {
 253   1        float tt;
 254   1        uchar high,low;
 255   1              //P1 |= 0x0f;
 256   1        while(dsreset() == 0)
 257   1              {
 258   2                      SendByte_74HC164(0);
 259   2                      P1 &= 0xfB;
 260   2              }
 261   1        delay(1);
 262   1              //tmpchange();
 263   1        tmpwritebyte(0xCC);                                   // 跳过 ROM 操作
 264   1        tmpwritebyte(0xBE);                                   // 读暂存寄存器
 265   1        low=tmpread();
 266   1        high=tmpread();
 267   1        temp=high;
 268   1        temp<<=8;                                                             // two byte compose a int variable
 269   1        temp=temp|low;
 270   1        tt=temp*0.0625;
 271   1        temp=tt*10+0.5;
 272   1        return temp;
 273   1      }
 274          
 275          
 276          
 277          /**********************************************************
 278          *  函数名称：数码管温度数据显示函数
 279          *  修改日期：2019-9-11
 280          *  修改人：ZhangHJ
 281          *  说明：1.temp表示需要显示的温度数值(百位数值)
 282          *                                2.A1、A2、A3分别了百位、十位、个位数值
 283          *                                3.控制段选信号dula和位选信号wela,以使数码管显示
 284          ***********************************************************/
 285          void Display_Tmp(uint temp)                             // 显示程序
 286          {
 287   1              uchar A1,A2,A2t,A3,ser;
 288   1              ser=temp/10;
 289   1              SBUF=ser;
 290   1              A1=temp/100;                                            // A1 --> 百位
 291   1              A2t=temp%100;                                           // A2t --> 后两位
 292   1              A2=A2t/10;                                                      // A2 --> 十位
 293   1              A3=A2t%10;                                                      // A3 --> 个位
 294   1              
 295   1              DP1 = 0;                                                        // 温度小数点开启
 296   1              DP = 1;                                                         // 时间小数点关闭
 297   1         
 298   1              // 控制数码管显示温度数值
 299   1              P1 |= 0x0f;
 300   1              SendByte_74HC164(A1);
 301   1              P1 &= 0xfB;
 302   1              delay(6);
C51 COMPILER V9.57.0.0   MAIN                                                              12/04/2019 10:54:19 PAGE 6   

 303   1              P1 |= 0x0f;
 304   1              
 305   1              SendByte_74HC164(A2);
 306   1              P1 &= 0xfD;
 307   1              delay(6);
 308   1              P1 |= 0x0f;
 309   1              
 310   1              SendByte_74HC164(A3);
 311   1              P1 &= 0xfE;
 312   1              delay(6);
 313   1              P1 |= 0x0f;
 314   1              
 315   1              SendByte_74HC164(10);
 316   1              P1 &= 0xf7;
 317   1              delay(6);
 318   1              P1 |= 0x0f;
 319   1      }
 320          
 321          
 322          
 323          /**********************************************************
 324          *  函数名称：DS1302写操作函数
 325          *  日期：2019-10-4
 326          *  姓名：ZhangHJ
 327          *  说明：写操作包含两个参数,add表示要写入的地址;wdata表示要写入的数据
 328          *                                1. 读写操作需要先将RST拉高才能进行
 329          *                                2. 先写入控制字节,在时钟上升沿串行写入数据
 330          *                                3. 再写入数据字节,同样在时钟上升沿写入数据
 331          *                                4. 最后拉低RST禁止数据传输
 332          ***********************************************************/
 333          void DS1302Write(uchar add,uchar wdata)
 334          {
 335   1              uchar a;
 336   1              //wdata = hex(wdata);                                   // 转换为BCD码
 337   1              RST=0;                                                                  // 拉低RST引脚,终止数据传输
 338   1              SCLK=0;                                                                 // 拉低SCLK引脚,清零时钟线
 339   1              RST=1;                                                                  // 拉高RST引脚,所有数据传输都要拉高RST脚,启动控制逻辑
 340   1              //先写入控制字节
 341   1              for(a=0; a<8; a++)
 342   1              {
 343   2                              IO= add & 0x01;                                 // IO引脚准备好要写入的1位数据
 344   2                              SCLK=1;                                                 // SCLK上升沿,1位数据从IO脚写入,低位先写入
 345   2                              add>>=1;                                                // 数据右移1位
 346   2                              SCLK=0;                                                 // 拉低SCLK,为下次写入准备,循环8次写入1字节
 347   2              }
 348   1              //再写入数据字节
 349   1              for(a=0; a<8; a++)
 350   1              {
 351   2                              IO= wdata & 0x01;
 352   2                              SCLK=1;
 353   2                              wdata>>=1;
 354   2                              SCLK=0;
 355   2              }
 356   1              RST=0;                                                                  // 数据传输完拉低RST
 357   1      }  
 358          
 359          
 360          
 361          /**********************************************************
 362          *  函数名称：DS1302读操作函数
 363          *  日期：2019-10-4
 364          *  姓名：ZhangHJ
C51 COMPILER V9.57.0.0   MAIN                                                              12/04/2019 10:54:19 PAGE 7   

 365          *  说明：读操作只需一个参数,即需要读取的寄存器地址add
 366          *                                1. 首先需要将需要读取的地址(1Byte)写入寄存器,在上升沿进行写入操作
 367          *                                2. 之后读取该地址中的数据,在下降沿读取数据
 368          *                                3. 最后返回读取到的1Byte数据
 369          ***********************************************************/ 
 370          uchar DS1302Read(uchar add)
 371          {
 372   1              uchar a, rdata=0;
 373   1              RST = 0;                                                                // 拉低RST引脚,终止数据传输
 374   1              SCLK = 0;                                                               // 拉低SCLK引脚,清零时钟线
 375   1              RST = 1;                                                                // 拉高RST引脚,启动控制逻辑
 376   1              //发送控制字节
 377   1              for(a=0; a<8; a++)
 378   1              {
 379   2                      SCLK = 0;
 380   2                      IO = add & 0x01;
 381   2                      SCLK = 1;                                                       // 制造一个上升沿,写入地址
 382   2                      add >>= 1;
 383   2              }
 384   1              //读1字节数据
 385   1              for(a=0; a<8; a++)
 386   1              {
 387   2                      SCLK = 1;
 388   2                      rdata >>= 1;
 389   2                      SCLK = 0;                                                       // 制造一个下降沿,读取数据
 390   2                      if(IO)
 391   2                      {                                                                       // 如果读到1
 392   3                              rdata |= 0x80;                                  // 把最高位置为1,记录到rdata中
 393   3                      }
 394   2              }
 395   1              RST=0;                                                                  // 拉低RST
 396   1              //return dec(d);                                        // 读取的数据转换成十进制
 397   1              return rdata;
 398   1      }
 399          
 400          
 401          
 402          /**********************************************************
 403          *  函数名称：DS1302初始化函数
 404          *  日期：2019-10-4
 405          *  姓名：ZhangHJ
 406          *  说明：初始化即为对DS1302初始数据的写入
 407          *                                1. 首先需要关闭写保护,以允许数据写入
 408          *                                2. 之后按"秒分时日月周年"的顺序写入初始数据
 409          *                                3. 最后开启写保护,禁止数据写入
 410          ***********************************************************/ 
 411          void ds1302_init()
 412          {
 413   1         uchar k;
 414   1         DS1302Write(0x8e,0x00);                              // 禁止写保护，即允许数据写入
 415   1              if(DS1302Read(0x81) & 0x80)                             // 掉电检测,时钟停止标志位
 416   1         for(k=0;k<7;k++)                                                     // 写入7个字节的时钟信号：秒分时日月周年
 417   1         {
 418   2           DS1302Write(write_addr[k],time[k]);
 419   2         }
 420   1         DS1302Write(0x8e,0x80);                              // 打开写保护,禁止数据写入
 421   1      }
 422          
 423          
 424          
 425          
 426          /**********************************************************
C51 COMPILER V9.57.0.0   MAIN                                                              12/04/2019 10:54:19 PAGE 8   

 427          *  函数名称：DS1302数据读取函数
 428          *  日期：2019-10-4
 429          *  姓名：ZhangHJ
 430          *  说明：数据读取即为按寄存器地址读取数据的过程
 431          *                                直接按地址读取寄存器中的数据,然后将数据放到time数组里保存即可
 432          ***********************************************************/ 
 433          void read_time()
 434          {
 435   1         uchar n;
 436   1         for(n=0;n<7;n++)
 437   1          time[n]=DS1302Read(read_addr[n]);   //读取秒分时日月周年
 438   1      }
 439          
 440          
 441          
 442          /**********************************************************
 443          *  函数名称：数码管时间数据显示函数
 444          *  修改日期：2019-10-4
 445          *  修改人：ZhangHJ
 446          *  说明：1.     A0~A9表示从秒到月的时间数值,按此规律可以计算到年
 447          *                                2.     DP表示时间分割的小数点,低电平选中
 448          *                                3.     最后通过控制位选和段选点亮数码管,显示时间
 449          ***********************************************************/
 450          void Display_Time()                                                     // 显示程序
 451          {
 452   1              uchar A0,A1,A2,A3,A4,A5,A6,A7;
 453   1      //      uchar A8,A9;
 454   1              A0 = dec(time[0])/10;                                   // A0-->秒十位
 455   1              A1 = dec(time[0])%10;                                   // A1-->秒个位
 456   1              A2 = dec(time[1])/10;                                   // A2-->分十位
 457   1              A3 = dec(time[1])%10;                                   // A3-->分个位
 458   1              A4 = dec(time[2])/10;                                   // A4-->时十位
 459   1              A5 = dec(time[2])%10;                                   // A5-->时个位
 460   1              A6 = dec(time[3])/10;                                   // A6-->日十位
 461   1              A7 = dec(time[3])%10;                                   // A7-->日个位
 462   1      //      A8 = dec(time[4])/10;                                   // A8-->月十位
 463   1      //      A9 = dec(time[4])%10;                                   // A9-->月个位
 464   1              
 465   1              DP1 = 1;                                                                // 温度小数点关闭
 466   1              flag ++;                                                                // 时间点闪烁计数
 467   1              if(flag >= 134)
 468   1              {
 469   2                      DP = ~DP;
 470   2                      flag = 0;
 471   2              }
 472   1         
 473   1              // 控制数码管显示温度数值
 474   1              P1 |= 0x0f;
 475   1              SendByte_74HC164(A4);                                   // A4-->时十位
 476   1              P1 &= 0xf7;
 477   1              delay(6);
 478   1              P1 |= 0x0f;
 479   1              
 480   1              SendByte_74HC164(A5);                                   // A5-->时个位
 481   1              P1 &= 0xfB;
 482   1              delay(6);
 483   1              P1 |= 0x0f;
 484   1              
 485   1              SendByte_74HC164(A2);                                   // A2-->分十位
 486   1              P1 &= 0xfd;
 487   1              delay(6);
 488   1              P1 |= 0x0f;
C51 COMPILER V9.57.0.0   MAIN                                                              12/04/2019 10:54:19 PAGE 9   

 489   1              
 490   1              SendByte_74HC164(A3);                                   // A3-->分个位
 491   1              P1 &= 0xfe;
 492   1              delay(6);
 493   1              P1 |= 0x0f;
 494   1      }
 495          
 496          
 497          /**********************************************************
 498          *  函数名称：配置外部中断0
 499          *  日期：2019-10-22
 500          *  姓名：ZhangHJ
 501          *  说明：1. 选择为下降沿触发方式(为1代表下降沿触发，为0代表低电平触发)
 502          *                2. 使能外部中断0
 503          *                3. 使能总中断
 504          ***********************************************************/
 505          void configExtInt0()
 506          {
 507   1              IT0 = 1;        //选择为下降沿触发方式(为1代表下降沿触发，为0代表低电平触发)
 508   1              EX0 = 1;        //使能外部中断0
 509   1              EA = 1;         //使能总中断
 510   1      }
 511          
 512          
 513          /**********************************************************
 514          *  函数名称：外部中断0服务函数
 515          *  日期：2019-11-4
 516          *  姓名：ZhangHJ
 517          *  说明：中断服务函数功能为,使功能显示标志位 DISP_FLAG 循环切换
 518          ***********************************************************/
 519          void extInt0() interrupt 0
 520          {
 521   1              EA = 0;                                                 // 关闭总中断
 522   1              Delay50ms();                                    // 延时防抖
 523   1              if(KEY == 0)
 524   1              {
 525   2                      P1 |= 0x0f;                                     // 关闭位选,清屏
 526   2                      DISP_FLAG = ~DISP_FLAG;         // 显示其他功能
 527   2              }
 528   1              EA = 1;                                                 // 开启总中断
 529   1      }
 530          
 531          
 532          
 533          // 主函数功能：默认显示时间(初始化时间为“2019年10月4日18:55:00”),按住INT0按键时,会显示温度
 534          void main()
 535          {
 536   1              uchar a;
 537   1              configExtInt0();                                                                // 配置外部中断0
 538   1              ds1302_init();                                                                  // DS1302日期初始化
 539   1              while(1)
 540   1              {
 541   2                      if(DISP_FLAG == 1)                                                      // 时间显示
 542   2                      {
 543   3                              read_time();                                                    // DS1302读取当前时间
 544   3                              Display_Time();                                                 // 显示当前时间
 545   3                      }
 546   2                      else                                                                            // 温度显示
 547   2                      {
 548   3                                      tmpchange();                                            // 温度转换
 549   3                                      for(a=40;a>0;a--)                                       // 延时,保持连续显示
 550   3                                      {
C51 COMPILER V9.57.0.0   MAIN                                                              12/04/2019 10:54:19 PAGE 10  

 551   4                                              Display_Tmp(tmp());                             // 进行温度转换和数值显示
 552   4                                      }
 553   3                      }
 554   2              }
 555   1      }
 556          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1066    ----
   CONSTANT SIZE    =     25    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
