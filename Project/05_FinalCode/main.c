#include <reg51.h>
#include <intrins.h>
#define uchar unsigned char
#define uint unsigned int
#define dec(dat) ((dat>>4)*10+(dat&0x0f)) 		// BCD码转十进制

sbit IO = P1^4;					// DS1302 数据输入输出线
sbit RST = P1^6;				// DS1302 复位信号线
sbit SCLK = P1^5;				// DS1302 时钟信号线
sbit DS = P1^7;					// DS18B20 数据端口
sbit DAT = P3^0;				// 74HC164 数据输入端口
sbit CLK = P3^1;				// 74HC164 时钟输入端口
sbit DP = P3^7;					// 时间分割点
sbit DP1 = P3^5;				// 温度小数点
sbit KEY = P3^2;				// 按键INT0
uint flag = 0;					// 时间小数点闪烁计数
uint temp;							// 温度变量

uchar code write_addr[]={0x80,0x82,0x84,0x86,0x88,0x8a,0x8c};		// DS1302写地址
uchar code read_addr[]={0x81,0x83,0x85,0x87,0x89,0x8b,0x8d};		// DS1302读地址

// 定义数码管段选(不加小数点0~9、℃)
uchar code table1[]={0x81,0xD7,0xC8,0xC2,0x96,0xA2,0xA0,0xC7,0x80,0x82,0xA9};

// 存储顺序是秒分时日月周年,存储格式是用BCD码
uchar time[7]={0,0x55,0x18,0x04,0x10,0x05,0x19};  //初始化的时间为2019年10月4日18:55:00



/**********************************************************
*  函数名称：低精度延时函数
*  日期：2019-9-7
*  姓名：ZhangHJ
*  说明：嵌套循环延时
***********************************************************/
void delay(unsigned int mstime)
{
	int i,j;
	for(i=mstime; i>=0; i--)
		for(j=114; j>=0; j--);
}



/**********************************************************
*  函数名称：74HC164发送Byte数据函数
*  日期：2019-9-29
*  姓名：ZhangHJ
*  说明：74HC164移位寄存器输入一字节数据发给寄存器
***********************************************************/
void SendByte_74HC164(uchar byte)
{
	uchar num,c;
	num=table1[byte];
	for(c=0; c<8; c++)
	{
		DAT=num&0x01;		// P3^0 --> 0000 000x
		CLK=0;					// 制造一个上升沿
		CLK=1;
		num>>=1;				// 将数据发送到寄存器
	}
}



/**********************************************************
*  函数名称：DS18B20发送复位和初始化命令函数
*  修改日期：2019-9-9
*  修改人：ZhangHJ
*  说明：1. 对于单片机: 单片机首先发出480-960us的低电平脉冲,
*				 		释放总线为高电平(上拉电阻拉高),在随后的480us进行检测,
*				 		如果出现低电平，说明器件应答正常.B
*				 2. 对于DS18B20: 上电后就检测是否有480/960us的低电平脉冲,
*						如果有低电平,在总线释放之后，等待15-60us,
*						将电平拉低60-240us,告诉主机已经准备好.
***********************************************************/
uchar dsreset(void)					// send reset and initialization command
{
  uint i;
  DS = 0;										// 先将端口拉低
  i=120;										// 维持低电平状态480us~960us
  while(i>0)i--;
  DS = 1;										// 然后释放总线(将总线拉高),若DS18B20做出反应,将会将在15us~60us后将总线拉低
	// 等待DS18B20响应
	i = 0;
	while(DS)									// 在DS高电平时等待
	{
		i++;
		if(i > 50000)						// 等待时间大于60us,说明响应失败
		{
			return 0;
		}
	}
	return 1;
}



/**********************************************************
*  函数名称：DS18B20读1bit数据函数
*  修改日期：2019-9-9
*  修改人：ZhangHJ
*  说明：1.首先单片机端口拉低 1 us (i++),
*				 2.然后释放总线,拉高总线,
*				 3.等待几位秒，是为了让 DS18B20 数据稳定,
*				 4.在15 us 内读取DS数据,
*				 5.接下来进行延时等待采样周期完成。
*				 详见DS18B20资料2.8.3.1读/写时间片
***********************************************************/
bit tmpreadbit(void)				// read a bit data
{
	uint i;
	bit dat;									// 定义位数据 (dat = 0 or 1)
	DS = 0;										// 先将端口拉低
	_nop_();									// 延时 2us ,要求至少保持1us
	DS = 1;										// 再将端口拉高
	i=8;while(i>0)i--;				// 等待DS数据稳定,要求的至少延时15us以上
	dat = DS;									// 数据传输
	i=15;while(i>0)i--;				// 等待数据采样周期完成,要求不低于60us
	return (dat);
}



/**********************************************************
*  函数名称：DS18B20读1Byte数据函数
*  修改日期：2019-9-9
*  修改人：ZhangHJ
*  说明：1.首先初始化字节数据变量dat为 0
*				 2.循环 8 次,调用tmpreadbit函数,读 8bit 数据
*				 3.读出的数据暂存到 j ,之后进行移位和按位或操作
*				 4.效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
*				 5.最后返回读到的字节数据
***********************************************************/
uchar tmpread(void)					// read a byte date
{
	uchar i,j,dat;
  dat = 0;									// 初始化数据变量为 0
  for(i=1;i<=8;i++)					// 循环 8 次,调用tmpreadbit函数,读 8bit 数据
  {
    j = tmpreadbit();				// 读出的数据暂存到 j
    dat = (j<<7)|(dat>>1);	// 效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
  }
  return(dat);							// 返回读到的字节
}



/**********************************************************
*  函数名称：DS18B20写入1Byte数据函数
*  修改日期：2019-9-11
*  修改人：ZhangHJ
*  说明：1.将对待写入数据dat进行位操作,将dat末位数值赋值给位数据testb
*				 2.通过判断testb得到写 0 还是写 1
*				 3.若是写 0 操作,将 DS 拉低,进行<60us的延时,再将DS拉高,进行>1us的延时
*				 4.若是写 1 操作,将 DS 拉低,进行>1us的延时,再将DS拉高,进行<60us的延时
*				 5.循环执行2、3、4操作8次,写入1字节数据
*				 详见18B20资料“2.8.3.1读/写时间片”章节
***********************************************************/
void tmpwritebyte(uchar dat)   //write a byte to ds18b20
{
  uint i;
  uchar j;
  bit testb;
  for(j=1;j<=8;j++)
  {
    testb = dat&0x01;
    dat = dat>>1;
    if(testb)     						// write 1
    {
      DS=0;
      i=8;while(i>0)i--;;			// 延时要求15~60us内
      DS=1;
      i=15;while(i>0)i--;			// 要求不低于60us
    }
    else
    {
      DS = 0;       					// write 0
      i=15;while(i>0)i--;
      DS = 1;
      i++;i++;
    }
  }
}



/**********************************************************
*  函数名称：DS18B20温度转换函数
*  修改日期：2019-9-11
*  修改人：ZhangHJ
*  说明：1.首先进行18B20初始化
*				 2.进行适当延时
*				 3.发送跳过光刻ROM指令
*				 4.发送RAM指令,进行温度转换
*				 详见18B20资料“2.8.3.1存储器操作命令”章节
***********************************************************/
void tmpchange(void)					// DS18B20 begin change
{
  while(dsreset() == 0)
	{
		SendByte_74HC164(0);
		P1 &= 0xfB;
	}
  delay(1);
  tmpwritebyte(0xCC);					// 跳过 ROM 操作
  tmpwritebyte(0x44);					// 启动一次温度转换
}



/**********************************************************
*  函数名称：DS18B20温度转换完整过程函数
*  修改日期：2019-9-11
*  修改人：ZhangHJ
*  说明：1.首先进行18B20初始化
*				 2.进行适当延时
*				 3.发送跳过光刻ROM指令
*				 4.发送RAM指令,进行温度转换
*				 5.读取两个8位数据,放到16位寄存器 temp 中
*				 6.将读取到的二进制数据(默认为正数),转换为十进制数据
*				 7.返回温度数据
*				 详见18B20资料“2.8.3.1存储器操作命令”章节
***********************************************************/
uint tmp()										// get the temperature
{
  float tt;
  uchar high,low;
	//P1 |= 0x0f;
  while(dsreset() == 0)
	{
		SendByte_74HC164(0);
		P1 &= 0xfB;
	}
  delay(1);
	//tmpchange();
  tmpwritebyte(0xCC);					// 跳过 ROM 操作
  tmpwritebyte(0xBE);					// 读暂存寄存器
  low=tmpread();
  high=tmpread();
  temp=high;
  temp<<=8;										// two byte compose a int variable
  temp=temp|low;
  tt=temp*0.0625;
  temp=tt*10+0.5;
  return temp;
}



/**********************************************************
*  函数名称：数码管温度数据显示函数
*  修改日期：2019-9-11
*  修改人：ZhangHJ
*  说明：1.temp表示需要显示的温度数值(百位数值)
*				 2.A1、A2、A3分别了百位、十位、个位数值
*				 3.控制段选信号dula和位选信号wela,以使数码管显示
***********************************************************/
void Display_Tmp(uint temp)				// 显示程序
{
	uchar A1,A2,A2t,A3,ser;
	ser=temp/10;
	SBUF=ser;
	A1=temp/100;								// A1 --> 百位
	A2t=temp%100;								// A2t --> 后两位
	A2=A2t/10;									// A2 --> 十位
	A3=A2t%10;									// A3 --> 个位
	
	DP1 = 0;										// 温度小数点开启
	DP = 1;											// 时间小数点关闭
   
	// 控制数码管显示温度数值
	P1 |= 0x0f;
	SendByte_74HC164(A1);
	P1 &= 0xfB;
	delay(6);
	P1 |= 0x0f;
	
	SendByte_74HC164(A2);
	P1 &= 0xfD;
	delay(6);
	P1 |= 0x0f;
	
	SendByte_74HC164(A3);
	P1 &= 0xfE;
	delay(6);
	P1 |= 0x0f;
	
	SendByte_74HC164(10);
	P1 &= 0xf7;
	delay(6);
	P1 |= 0x0f;
}



/**********************************************************
*  函数名称：DS1302写操作函数
*  日期：2019-10-4
*  姓名：ZhangHJ
*  说明：写操作包含两个参数,add表示要写入的地址;wdata表示要写入的数据
*				 1. 读写操作需要先将RST拉高才能进行
*				 2. 先写入控制字节,在时钟上升沿串行写入数据
*				 3. 再写入数据字节,同样在时钟上升沿写入数据
*				 4. 最后拉低RST禁止数据传输
***********************************************************/
void DS1302Write(uchar add,uchar wdata)
{
	uchar a;
	//wdata = hex(wdata);		// 转换为BCD码
	RST=0;									// 拉低RST引脚,终止数据传输
	SCLK=0;									// 拉低SCLK引脚,清零时钟线
	RST=1;									// 拉高RST引脚,所有数据传输都要拉高RST脚,启动控制逻辑
	//先写入控制字节
	for(a=0; a<8; a++)
	{
			IO= add & 0x01;			// IO引脚准备好要写入的1位数据
			SCLK=1;							// SCLK上升沿,1位数据从IO脚写入,低位先写入
			add>>=1;						// 数据右移1位
			SCLK=0;							// 拉低SCLK,为下次写入准备,循环8次写入1字节
	}
	//再写入数据字节
	for(a=0; a<8; a++)
	{
			IO= wdata & 0x01;
			SCLK=1;
			wdata>>=1;
			SCLK=0;
	}
	RST=0;									// 数据传输完拉低RST
}  



/**********************************************************
*  函数名称：DS1302读操作函数
*  日期：2019-10-4
*  姓名：ZhangHJ
*  说明：读操作只需一个参数,即需要读取的寄存器地址add
*				 1. 首先需要将需要读取的地址(1Byte)写入寄存器,在上升沿进行写入操作
*				 2. 之后读取该地址中的数据,在下降沿读取数据
*				 3. 最后返回读取到的1Byte数据
***********************************************************/ 
uchar DS1302Read(uchar add)
{
	uchar a, rdata=0;
	RST = 0;											// 拉低RST引脚,终止数据传输
	SCLK = 0;											// 拉低SCLK引脚,清零时钟线
	RST = 1;											// 拉高RST引脚,启动控制逻辑
	//发送控制字节
	for(a=0; a<8; a++)
	{
		SCLK = 0;
		IO = add & 0x01;
		SCLK = 1;										// 制造一个上升沿,写入地址
		add >>= 1;
	}
	//读1字节数据
	for(a=0; a<8; a++)
	{
		SCLK = 1;
		rdata >>= 1;
		SCLK = 0;										// 制造一个下降沿,读取数据
		if(IO)
		{														// 如果读到1
			rdata |= 0x80;						// 把最高位置为1,记录到rdata中
		}
	}
	RST=0;												// 拉低RST
	//return dec(d);        			// 读取的数据转换成十进制
	return rdata;
}



/**********************************************************
*  函数名称：DS1302初始化函数
*  日期：2019-10-4
*  姓名：ZhangHJ
*  说明：初始化即为对DS1302初始数据的写入
*				 1. 首先需要关闭写保护,以允许数据写入
*				 2. 之后按"秒分时日月周年"的顺序写入初始数据
*				 3. 最后开启写保护,禁止数据写入
***********************************************************/ 
void ds1302_init()
{
   uchar k;
   DS1302Write(0x8e,0x00);  		// 禁止写保护，即允许数据写入
   for(k=0;k<7;k++)							// 写入7个字节的时钟信号：秒分时日月周年
   {
     DS1302Write(write_addr[k],time[k]);
   }
   DS1302Write(0x8e,0x80);  		// 打开写保护,禁止数据写入
}




/**********************************************************
*  函数名称：DS1302数据读取函数
*  日期：2019-10-4
*  姓名：ZhangHJ
*  说明：数据读取即为按寄存器地址读取数据的过程
*				 直接按地址读取寄存器中的数据,然后将数据放到time数组里保存即可
***********************************************************/ 
void read_time()
{
   uchar n;
   for(n=0;n<7;n++)
    time[n]=DS1302Read(read_addr[n]);   //读取秒分时日月周年
}



/**********************************************************
*  函数名称：数码管时间数据显示函数
*  修改日期：2019-10-4
*  修改人：ZhangHJ
*  说明：1.	A0~A9表示从秒到月的时间数值,按此规律可以计算到年
*				 2.	DP表示时间分割的小数点,低电平选中
*				 3.	最后通过控制位选和段选点亮数码管,显示时间
***********************************************************/
void Display_Time()							// 显示程序
{
	uchar A0,A1,A2,A3,A4,A5,A6,A7,A8,A9;
	A0 = dec(time[0])/10;					// A0-->秒十位
	A1 = dec(time[0])%10;					// A1-->秒个位
	A2 = dec(time[1])/10;					// A2-->分十位
	A3 = dec(time[1])%10;					// A3-->分个位
	A4 = dec(time[2])/10;					// A4-->时十位
	A5 = dec(time[2])%10;					// A5-->时个位
	A6 = dec(time[3])/10;					// A6-->日十位
	A7 = dec(time[3])%10;					// A7-->日个位
	A8 = dec(time[3])/10;					// A8-->月十位
	A9 = dec(time[3])%10;					// A9-->月个位
	
	DP1 = 1;											// 温度小数点关闭
	flag ++;											// 时间点闪烁计数
	if(flag >= 134)
	{
		DP = ~DP;
		flag = 0;
	}
   
	// 控制数码管显示温度数值
	P1 |= 0x0f;
	SendByte_74HC164(A4);					// A4-->时十位
	P1 &= 0xf7;
	delay(6);
	P1 |= 0x0f;
	
	SendByte_74HC164(A5);					// A5-->时个位
	P1 &= 0xfB;
	delay(6);
	P1 |= 0x0f;
	
	SendByte_74HC164(A2);					// A2-->分十位
	P1 &= 0xfd;
	delay(6);
	P1 |= 0x0f;
	
	SendByte_74HC164(A3);					// A3-->分个位
	P1 &= 0xfe;
	delay(6);
	P1 |= 0x0f;
}



// 主函数功能：默认显示时间(初始化时间为“2019年10月4日18:55:00”),按住INT0按键时,会显示温度
void main()
{
	uchar a;
	ds1302_init();									// DS1302日期初始化
	while(1)
	{
		// 时间显示
		read_time();									// DS1302读取当前时间
		Display_Time();								// 显示当前时间
		// 按键处理
		if (KEY == 0)
		{
			delay(5);
			while(KEY == 0)							// 按键消抖
			{
				// 温度显示
				tmpchange();							// 首次温度转换
				for(a=50;a>0;a--)					// 延时,保持连续显示
				{
					Display_Tmp(tmp());			// 进行温度转换和数值显示
				}
			}
		}
	}
}

