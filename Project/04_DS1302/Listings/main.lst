C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 19:19:20 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\keil\install\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include<reg51.h>
   2          #define uchar unsigned char
   3          #define uint unsigned int
   4          #define dec(dat) ((dat>>4)*10+(dat&0x0f))     // BCD码转十进制
   5          
   6          sbit IO = P1^4;         // DS1302 数据输入输出线
   7          sbit RST = P1^6;        // DS1302 复位信号线
   8          sbit SCLK = P1^5;       // DS1302 时钟信号线
   9          sbit DS = P1^7;         // DS18B20 数据端口
  10          sbit DAT = P3^0;        // 74HC164 数据输入端口
  11          sbit CLK = P3^1;        // 74HC164 时钟输入端口
  12          sbit DP = P3^7;         // 时间分割点
  13          uint flag = 0;          // 小数点闪烁计数
  14          
  15          uchar code write_addr[]={0x80,0x82,0x84,0x86,0x88,0x8a,0x8c};   // DS1302写地址
  16          uchar code read_addr[]={0x81,0x83,0x85,0x87,0x89,0x8b,0x8d};    // DS1302读地址
  17          
  18          // 定义数码管段选(不加小数点0~9)
  19          uchar code table1[]={0x81,0xD7,0xC8,0xC2,0x96,0xA2,0xA0,0xC7,0x80,0x82};
  20          
  21          // 存储顺序是秒分时日月周年,存储格式是用BCD码
  22          uchar time[7]={0,0x55,0x18,0x04,0x10,0x05,0x19};  //初始化的时间为2019年10月4日18:55:00
  23          
  24          
  25          /**********************************************************
  26          *  函数名称：低精度延时函数
  27          *  日期：2019-9-7
  28          *  姓名：ZhangHJ
  29          *  说明：嵌套循环延时
  30          ***********************************************************/
  31          void delay(unsigned int mstime)
  32          {
  33   1        int i,j;
  34   1        for(i=mstime; i>=0; i--)
  35   1          for(j=114; j>=0; j--);
  36   1      }
  37          
  38          
  39          /**********************************************************
  40          *  函数名称：DS1302写操作函数
  41          *  日期：2019-10-4
  42          *  姓名：ZhangHJ
  43          *  说明：写操作包含两个参数,add表示要写入的地址;wdata表示要写入的数据
  44          *        1. 读写操作需要先将RST拉高才能进行
  45          *        2. 先写入控制字节,在时钟上升沿串行写入数据
  46          *        3. 再写入数据字节,同样在时钟上升沿写入数据
  47          *        4. 最后拉低RST禁止数据传输
  48          ***********************************************************/
  49          void DS1302Write(uchar add,uchar wdata)
  50          {
  51   1        uchar a;
  52   1        //wdata = hex(wdata);   // 转换为BCD码
  53   1        RST=0;                  // 拉低RST引脚,终止数据传输
  54   1        SCLK=0;                 // 拉低SCLK引脚,清零时钟线
C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 19:19:20 PAGE 2   

  55   1        RST=1;                  // 拉高RST引脚,所有数据传输都要拉高RST脚,启动控制逻辑
  56   1        //先写入控制字节
  57   1        for(a=0; a<8; a++)
  58   1        {
  59   2            IO= add & 0x01;     // IO引脚准备好要写入的1位数据
  60   2            SCLK=1;             // SCLK上升沿,1位数据从IO脚写入,低位先写入
  61   2            add>>=1;            // 数据右移1位
  62   2            SCLK=0;             // 拉低SCLK,为下次写入准备,循环8次写入1字节
  63   2        }
  64   1        //再写入数据字节
  65   1        for(a=0; a<8; a++)
  66   1        {
  67   2            IO= wdata & 0x01;
  68   2            SCLK=1;
  69   2            wdata>>=1;
  70   2            SCLK=0;
  71   2        }
  72   1        RST=0;                  // 数据传输完拉低RST
  73   1      }  
  74          
  75          
  76          
  77          /**********************************************************
  78          *  函数名称：DS1302读操作函数
  79          *  日期：2019-10-4
  80          *  姓名：ZhangHJ
  81          *  说明：读操作只需一个参数,即需要读取的寄存器地址add
  82          *        1. 首先需要将需要读取的地址(1Byte)写入寄存器,在上升沿进行写入操作
  83          *        2. 之后读取该地址中的数据,在下降沿读取数据
  84          *        3. 最后返回读取到的1Byte数据
  85          ***********************************************************/ 
  86          uchar DS1302Read(uchar add)
  87          {
  88   1        uchar a, rdata=0;
  89   1        RST = 0;                      // 拉低RST引脚,终止数据传输
  90   1        SCLK = 0;                     // 拉低SCLK引脚,清零时钟线
  91   1        RST = 1;                      // 拉高RST引脚,启动控制逻辑
  92   1        //发送控制字节
  93   1        for(a=0; a<8; a++)
  94   1        {
  95   2          SCLK = 0;
  96   2          IO = add & 0x01;
  97   2          SCLK = 1;                   // 制造一个上升沿,写入地址
  98   2          add >>= 1;
  99   2        }
 100   1        //读1字节数据
 101   1        for(a=0; a<8; a++)
 102   1        {
 103   2          SCLK = 1;
 104   2          rdata >>= 1;
 105   2          SCLK = 0;                   // 制造一个下降沿,读取数据
 106   2          if(IO)
 107   2          {                           // 如果读到1
 108   3            rdata |= 0x80;            // 把最高位置为1,记录到rdata中
 109   3          }
 110   2        }
 111   1        RST=0;                        // 拉低RST
 112   1        //return dec(d);              // 读取的数据转换成十进制
 113   1        return rdata;
 114   1      }
 115          
 116          
C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 19:19:20 PAGE 3   

 117          
 118          /**********************************************************
 119          *  函数名称：DS1302初始化函数
 120          *  日期：2019-10-4
 121          *  姓名：ZhangHJ
 122          *  说明：初始化即为对DS1302初始数据的写入
 123          *        1. 首先需要关闭写保护,以允许数据写入
 124          *        2. 之后按"秒分时日月周年"的顺序写入初始数据
 125          *        3. 最后开启写保护,禁止数据写入
 126          ***********************************************************/ 
 127          void ds1302_init()
 128          {
 129   1         uchar k;
 130   1         DS1302Write(0x8e,0x00);      // 禁止写保护，即允许数据写入
 131   1         for(k=0;k<7;k++)             // 写入7个字节的时钟信号：秒分时日月周年
 132   1         {
 133   2           DS1302Write(write_addr[k],time[k]);
 134   2         }
 135   1         DS1302Write(0x8e,0x80);      // 打开写保护,禁止数据写入
 136   1      }
 137          
 138          
 139          
 140          
 141          /**********************************************************
 142          *  函数名称：DS1302数据读取函数
 143          *  日期：2019-10-4
 144          *  姓名：ZhangHJ
 145          *  说明：数据读取即为按寄存器地址读取数据的过程
 146          *        直接按地址读取寄存器中的数据,然后将数据放到time数组里保存即可
 147          ***********************************************************/ 
 148          void read_time()
 149          {
 150   1         uchar n;
 151   1         for(n=0;n<7;n++)
 152   1          time[n]=DS1302Read(read_addr[n]);   //读取秒分时日月周年
 153   1      }
 154          
 155          
 156          
 157          
 158          /**********************************************************
 159          *  函数名称：74HC164发送Byte函数
 160          *  日期：2019-9-29
 161          *  姓名：ZhangHJ
 162          *  说明：74HC164移位寄存器输入一字节数据发给寄存器
 163          ***********************************************************/
 164          void SendByte_74HC164(uchar byte)
 165          {
 166   1        uchar num,c;
 167   1        num=table1[byte];
 168   1        for(c=0; c<8; c++)
 169   1        {
 170   2          DAT=num&0x01;   // P3^0 --> 0000 000x
 171   2          CLK=0;          // 制造一个上升沿
 172   2          CLK=1;
 173   2          num>>=1;        // 将数据发送到寄存器
 174   2        }
 175   1      }
 176          
 177          
 178          
C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 19:19:20 PAGE 4   

 179          
 180          /**********************************************************
 181          *  函数名称：数码管时间数据显示函数
 182          *  修改日期：2019-10-4
 183          *  修改人：ZhangHJ
 184          *  说明：1. A0~A9表示从秒到月的时间数值,按此规律可以计算到年
 185          *        2. DP表示时间分割的小数点,低电平选中
 186          *        3. 最后通过控制位选和段选点亮数码管,显示时间
 187          ***********************************************************/
 188          void display()                  // 显示程序
 189          {
 190   1        uchar A0,A1,A2,A3,A4,A5,A6,A7,A8,A9;
 191   1        A0 = dec(time[0])/10;         // A0-->秒十位
 192   1        A1 = dec(time[0])%10;         // A1-->秒个位
 193   1        A2 = dec(time[1])/10;         // A2-->分十位
 194   1        A3 = dec(time[1])%10;         // A3-->分个位
 195   1        A4 = dec(time[2])/10;         // A4-->时十位
 196   1        A5 = dec(time[2])%10;         // A5-->时个位
 197   1        A6 = dec(time[3])/10;         // A6-->日十位
 198   1        A7 = dec(time[3])%10;         // A7-->日个位
 199   1        A8 = dec(time[3])/10;         // A8-->月十位
 200   1        A9 = dec(time[3])%10;         // A9-->月个位
 201   1        
 202   1        // DP = 0;                    // 点分割
 203   1        flag ++;                      // 时间点闪烁计数
 204   1        if(flag >= 134)
 205   1        {
 206   2          DP = ~DP;
 207   2          flag = 0;
 208   2        }
 209   1         
 210   1        // 控制数码管显示温度数值
 211   1        P1 |= 0x0f;
 212   1        SendByte_74HC164(A4);         // A4-->时十位
 213   1        P1 &= 0xf7;
 214   1        delay(6);
 215   1        P1 |= 0x0f;
 216   1        
 217   1        SendByte_74HC164(A5);         // A5-->时个位
 218   1        P1 &= 0xfB;
 219   1        delay(6);
 220   1        P1 |= 0x0f;
 221   1        
 222   1        SendByte_74HC164(A2);         // A2-->分十位
 223   1        P1 &= 0xfd;
 224   1        delay(6);
 225   1        P1 |= 0x0f;
 226   1        
 227   1        SendByte_74HC164(A3);         // A3-->分个位
 228   1        P1 &= 0xfe;
 229   1        delay(6);
 230   1        P1 |= 0x0f;
 231   1      }
 232          
 233          
 234          // 主函数功能：设置初始时间为“2019年10月4日18:55:00”并不断显示时间
 235          void main()
 236          {
 237   1        ds1302_init();          // DS1302日期初始化
 238   1        while(1)
 239   1        {
 240   2          read_time();          // DS1302读取当前时间
C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 19:19:20 PAGE 5   

 241   2          display();            // 显示当前时间
 242   2        }
 243   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    568    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
