#include<reg51.h>
#define uchar unsigned char
#define uint unsigned int
#define dec(dat) ((dat>>4)*10+(dat&0x0f)) 		// BCD码转十进制

sbit IO = P1^4;					// DS1302 数据输入输出线
sbit RST = P1^6;				// DS1302 复位信号线
sbit SCLK = P1^5;				// DS1302 时钟信号线
sbit DS = P1^7;					// DS18B20 数据端口
sbit DAT = P3^0;				// 74HC164 数据输入端口
sbit CLK = P3^1;				// 74HC164 时钟输入端口
sbit DP = P3^7;					// 时间分割点
uint flag = 0;					// 小数点闪烁计数

uchar code write_addr[]={0x80,0x82,0x84,0x86,0x88,0x8a,0x8c};		// DS1302写地址
uchar code read_addr[]={0x81,0x83,0x85,0x87,0x89,0x8b,0x8d};		// DS1302读地址

// 定义数码管段选(不加小数点0~9)
uchar code table1[]={0x81,0xD7,0xC8,0xC2,0x96,0xA2,0xA0,0xC7,0x80,0x82};

// 存储顺序是秒分时日月周年,存储格式是用BCD码
uchar time[7]={0,0x55,0x18,0x04,0x10,0x05,0x19};  //初始化的时间为2019年10月4日18:55:00


/**********************************************************
*  函数名称：低精度延时函数
*  日期：2019-9-7
*  姓名：ZhangHJ
*  说明：嵌套循环延时
***********************************************************/
void delay(unsigned int mstime)
{
	int i,j;
	for(i=mstime; i>=0; i--)
		for(j=114; j>=0; j--);
}


/**********************************************************
*  函数名称：DS1302写操作函数
*  日期：2019-10-4
*  姓名：ZhangHJ
*  说明：写操作包含两个参数,add表示要写入的地址;wdata表示要写入的数据
*				 1. 读写操作需要先将RST拉高才能进行
*				 2. 先写入控制字节,在时钟上升沿串行写入数据
*				 3. 再写入数据字节,同样在时钟上升沿写入数据
*				 4. 最后拉低RST禁止数据传输
***********************************************************/
void DS1302Write(uchar add,uchar wdata)
{
	uchar a;
	//wdata = hex(wdata);					// 转换为BCD码
	RST=0;									// 拉低RST引脚,终止数据传输
	SCLK=0;									// 拉低SCLK引脚,清零时钟线
	RST=1;									// 拉高RST引脚,所有数据传输都要拉高RST脚,启动控制逻辑
	//先写入控制字节
	for(a=0; a<8; a++)
	{
			IO= add & 0x01;					// IO引脚准备好要写入的1位数据
			SCLK=1;							// SCLK上升沿,1位数据从IO脚写入,低位先写入
			add>>=1;						// 数据右移1位
			SCLK=0;							// 拉低SCLK,为下次写入准备,循环8次写入1字节
	}
	//再写入数据字节
	for(a=0; a<8; a++)
	{
			IO= wdata & 0x01;
			SCLK=1;
			wdata>>=1;
			SCLK=0;
	}
	RST=0;									// 数据传输完拉低RST
}  



/**********************************************************
*  函数名称：DS1302读操作函数
*  日期：2019-10-4
*  姓名：ZhangHJ
*  说明：读操作只需一个参数,即需要读取的寄存器地址add
*				 1. 首先需要将需要读取的地址(1Byte)写入寄存器,在上升沿进行写入操作
*				 2. 之后读取该地址中的数据,在下降沿读取数据
*				 3. 最后返回读取到的1Byte数据
***********************************************************/ 
uchar DS1302Read(uchar add)
{
	uchar a, rdata=0;
	RST = 0;											// 拉低RST引脚,终止数据传输
	SCLK = 0;											// 拉低SCLK引脚,清零时钟线
	RST = 1;											// 拉高RST引脚,启动控制逻辑
	//发送控制字节
	for(a=0; a<8; a++)
	{
		SCLK = 0;
		IO = add & 0x01;
		SCLK = 1;										// 制造一个上升沿,写入地址
		add >>= 1;
	}
	//读1字节数据
	for(a=0; a<8; a++)
	{
		SCLK = 1;
		rdata >>= 1;
		SCLK = 0;										// 制造一个下降沿,读取数据
		if(IO)
		{												// 如果读到1
			rdata |= 0x80;								// 把最高位置为1,记录到rdata中
		}
	}
	RST=0;												// 拉低RST
	//return dec(d);        							// 读取的数据转换成十进制
	return rdata;
}



/**********************************************************
*  函数名称：DS1302初始化函数
*  日期：2019-10-4
*  姓名：ZhangHJ
*  说明：初始化即为对DS1302初始数据的写入
*				 1. 首先需要关闭写保护,以允许数据写入
*				 2. 之后按"秒分时日月周年"的顺序写入初始数据
*				 3. 最后开启写保护,禁止数据写入
***********************************************************/ 
void ds1302_init()
{
   uchar k;
   DS1302Write(0x8e,0x00);  				// 禁止写保护，即允许数据写入
	if(DS1302Read(0x81) & 0x80)				// 掉电检测,时钟停止标志位
   for(k=0;k<7;k++)							// 写入7个字节的时钟信号：秒分时日月周年
   {
     DS1302Write(write_addr[k],time[k]);
   }
   DS1302Write(0x8e,0x80);  				// 打开写保护,禁止数据写入
}




/**********************************************************
*  函数名称：DS1302数据读取函数
*  日期：2019-10-4
*  姓名：ZhangHJ
*  说明：数据读取即为按寄存器地址读取数据的过程
*				 直接按地址读取寄存器中的数据,然后将数据放到time数组里保存即可
***********************************************************/ 
void read_time()
{
   uchar n;
   for(n=0;n<7;n++)
    time[n]=DS1302Read(read_addr[n]);   //读取秒分时日月周年
}




/**********************************************************
*  函数名称：74HC164发送Byte函数
*  日期：2019-9-29
*  姓名：ZhangHJ
*  说明：74HC164移位寄存器输入一字节数据发给寄存器
***********************************************************/
void SendByte_74HC164(uchar byte)
{
	uchar num,c;
	num=table1[byte];
	for(c=0; c<8; c++)
	{
		DAT=num&0x01;			// P3^0 --> 0000 000x
		CLK=0;					// 制造一个上升沿
		CLK=1;
		num>>=1;				// 将数据发送到寄存器
	}
}




/**********************************************************
*  函数名称：数码管时间数据显示函数
*  修改日期：2019-10-4
*  修改人：ZhangHJ
*  说明：1.	A0~A9表示从秒到月的时间数值,按此规律可以计算到年
*				 2.	DP表示时间分割的小数点,低电平选中
*				 3.	最后通过控制位选和段选点亮数码管,显示时间
***********************************************************/
void display()									// 显示程序
{
	uchar A0,A1,A2,A3,A4,A5,A6,A7;
//	uchar A8,A9;
	A0 = dec(time[0])/10;					// A0-->秒十位
	A1 = dec(time[0])%10;					// A1-->秒个位
	A2 = dec(time[1])/10;					// A2-->分十位
	A3 = dec(time[1])%10;					// A3-->分个位
	A4 = dec(time[2])/10;					// A4-->时十位
	A5 = dec(time[2])%10;					// A5-->时个位
	A6 = dec(time[3])/10;					// A6-->日十位
	A7 = dec(time[3])%10;					// A7-->日个位
//	A8 = dec(time[4])/10;					// A8-->月十位
//	A9 = dec(time[4])%10;					// A9-->月个位
	
	// DP = 0;								// 点分割
	flag ++;								// 时间点闪烁计数
	if(flag >= 134)
	{
		DP = ~DP;
		flag = 0;
	}
   
	// 控制数码管显示温度数值
	P1 |= 0x0f;
	SendByte_74HC164(A4);					// A4-->时十位
	P1 &= 0xf7;
	delay(6);
	P1 |= 0x0f;
	
	SendByte_74HC164(A5);					// A5-->时个位
	P1 &= 0xfB;
	delay(6);
	P1 |= 0x0f;
	
	SendByte_74HC164(A2);					// A2-->分十位
	P1 &= 0xfd;
	delay(6);
	P1 |= 0x0f;
	
	SendByte_74HC164(A3);					// A3-->分个位
	P1 &= 0xfe;
	delay(6);
	P1 |= 0x0f;
}


// 主函数功能：设置初始时间为“2019年10月4日18:55:00”并不断显示时间
void main()
{
	ds1302_init();						// DS1302日期初始化
	while(1)
	{
		read_time();					// DS1302读取当前时间
		display();						// 显示当前时间
	}
}